#!/usr/bin/env node
var xe=Object.create;var C=Object.defineProperty;var Ce=Object.getOwnPropertyDescriptor;var Re=Object.getOwnPropertyNames;var Se=Object.getPrototypeOf,Te=Object.prototype.hasOwnProperty;var p=(e,o)=>()=>(e&&(o=e(e=0)),o);var We=(e,o)=>()=>(o||e((o={exports:{}}).exports,o),o.exports),y=(e,o)=>{for(var t in o)C(e,t,{get:o[t],enumerable:!0})},A=(e,o,t,s)=>{if(o&&typeof o=="object"||typeof o=="function")for(let r of Re(o))!Te.call(e,r)&&r!==t&&C(e,r,{get:()=>o[r],enumerable:!(s=Ce(o,r))||s.enumerable});return e};var c=(e,o,t)=>(t=e!=null?xe(Se(e)):{},A(o||!e||!e.__esModule?C(t,"default",{value:e,enumerable:!0}):t,e)),v=e=>A(C({},"__esModule",{value:!0}),e);var q=We((oo,Fe)=>{Fe.exports={name:"@co2-lab/mws",version:"1.0.0",repository:"https://github.com/co2-lab/mws.git",author:"Codeco <adrielcodeco@hotmail.com>",license:"MIT",bin:{mws:"bin/mws"},imports:{"#src/*":"./dist/*"},scripts:{build:"node esbuild.js",typecheck:"tsc","yarn:pack":"yarn pack && cpy 'onhand-*.tgz' '../../releases'"},dependencies:{octokit:"^2.0.14",prompts:"^2.4.2","simple-git":"^3.17.0",yargs:"^17.7.1"},devDependencies:{"@types/node":"^18.15.11","@types/yargs":"^17.0.24",esbuild:"^0.17.15",typescript:"^5.0.3"}}});var g,k=p(()=>{g=e=>e?console.log:(...o)=>{}});var l,N,E,U,B,u,D,J,R,S,$,L,T,f=p(()=>{l=c(require("simple-git")),N=require("octokit");k();E=async(e,o)=>{let t=g(o);try{let s=new N.Octokit({auth:e}),{data:{login:r}}=await s.rest.users.getAuthenticated();return r}catch(s){return t(s),""}},U=async(e,o,t,s,r)=>{let i=g(r);try{return(await new N.Octokit({auth:e}).rest.repos.createUsingTemplate({template_owner:"co2lab",template_repo:"onhand-repo-template",name:o,owner:s,private:t})).data}catch(n){throw i(n),"This repo name is invalid or is already in use, try another."}},B=async(e,o)=>(0,l.default)(e).init().addRemote("origin",o),u=async(e,o)=>(0,l.default)(e).pull("origin",o),D=async(e,o)=>(0,l.default)(e).add("./*").commit(o),J=async(e,o)=>(0,l.default)(e).push(["-u","origin",`HEAD:${o}`]),R=e=>(0,l.default)(e).status(),S=(e,o)=>(0,l.default)(e).clone(o),$=async(e,o)=>{let t=(0,l.default)(e);return t.raw(["switch",o]).catch(()=>t.raw(["switch","-c",o]))},L=(e,o)=>(0,l.default)(e).checkout(["-t",`origin/${o}`]),T=(e,o)=>(0,l.default)(e).checkout([`tags/${o}`,"-b",o])});var m,M,W,d,_,z,H,w=p(()=>{m=c(require("fs")),M=c(require("path")),W=(e=!1,o=process.cwd())=>{let t=M.default.resolve(o,"onhand.workspace.json");if(!m.default.existsSync(t))if(e)m.default.writeFileSync(t,"",{encoding:"utf-8"});else throw new Error("onhand.workspace.json not found");return t},d=()=>{let e=W(),o=m.default.readFileSync(e,{encoding:"utf-8"});return JSON.parse(o)},_=(e,o=process.cwd())=>{let t=W(!0,o);m.default.writeFileSync(t,JSON.stringify(e),{encoding:"utf-8"})},z=e=>{var r;let o=W(),t=m.default.readFileSync(o,{encoding:"utf-8"}),s=JSON.parse(t);(r=s.repositories)==null||r.push(e),m.default.writeFileSync(o,JSON.stringify(s),{encoding:"utf-8"})},H=e=>{var r;let o=W(),t=m.default.readFileSync(o,{encoding:"utf-8"}),s=JSON.parse(t);s.repositories=(r=s.repositories)==null?void 0:r.filter(i=>i.folder!==e),m.default.writeFileSync(o,JSON.stringify(s),{encoding:"utf-8"})}});var P,K,Q=p(()=>{P=c(require("path"));k();f();w();K=async e=>{let{gitUrl:o,folderName:t,connection:s,connectedTo:r,verbose:i}=e,{repositoriesFolder:n}=d(),a=P.default.resolve(process.cwd(),n);g(i)("Starting to add a repo..."),await S(a,o),a=P.default.resolve(a,t);let h={folder:t,repo:o},{tracking:F}=await R(a);s==="branch"?(F===`origin/${r}`?await u(a,r):await L(a,r),h.branch=r):(await T(a,r),h.tag=r),z(h)}});var X={};y(X,{builder:()=>Pe,command:()=>Ne,desc:()=>Oe,handler:()=>Ge});async function Ie(e){let o={},t=await(0,V.default)([{type:"text",name:"gitUrl",message:"What is the git url of the repo that you want to clone ?"},{type:"text",name:"folderName",message:"What should be the folder name where it should be cloned ?",initial:(r,i,n)=>{let a=r.split("/");return a[a.length-1].replace(/\.git$/,"")}},{type:"select",name:"connection",message:"Connect to ... ?",choices:[{title:"Branch",description:"Connected to the branch",value:"branch"},{title:"Tag",description:"Connected to the tag",value:"tag"}],initial:0},{type:"text",name:"connectedTo",message:"pull from ... ?",initial:(r,i,n)=>{switch(r){case"branch":return"main";case"tag":return"v1.0.0";default:return""}}}]),s=Object.assign({},o,e,t);if(!s.gitUrl)throw new Error("The git url is required");if(!s.connection||!s.connectedTo)throw new Error("invalid repo connection");await K(s)}var V,Ne,Oe,Pe,Ge,Y=p(()=>{V=c(require("prompts"));Q();Ne="add-repo",Oe="Add a repository to workspace",Pe=function(e){},Ge=function(e){(async()=>{await Ie({verbose:!!e.verbose})})().catch(o=>{console.error(o),process.exit(1)})}});var Z,ee,oe=p(()=>{Z=c(require("path"));k();f();w();ee=async e=>{let{workspaceName:o,repositoriesFolder:t,pushToGit:s,githubAccessToken:r,githubProjectName:i,githubDefaultBranchName:n,githubPrivateRepo:a,githubLogin:x,verbose:h}=e,F=process.cwd(),b=Z.default.resolve(F,o),I=g(h);I("Starting workspace creation...");let j="";if(s){I("Creating github repo...");let{clone_url:ke}=await U(r,i,a,x,h);j=ke}await _({workspaceName:o,repositoriesFolder:t,repositories:[]},b),s&&(await B(b,j),await u(b,n),await D(b,"chore: Initializing the workspace"),await J(b,n))}});var re={};y(re,{builder:()=>qe,command:()=>je,desc:()=>Ae,handler:()=>Ee});async function Ue(e){let{verbose:o}=e,t={workspaceFolder:".",workspaceName:"workspace",repositoriesFolder:"repositories",githubLogin:"",githubDefaultBranchName:"main"},s=await(0,te.default)([{type:"text",name:"workspaceFolder",message:"Where is the workspace folder ?",onRender:i=>{this.msg=i.cyan('relative or absolute path default: "."')},initial:t.workspaceFolder},{type:"text",name:"workspaceName",message:"What will be the workspace name ?",initial:t.workspaceName},{type:"text",name:"repositoriesFolder",message:"What will be the name of the repositories folder ?",initial:t.repositoriesFolder},{type:"confirm",name:"pushToGit",message:"Do you want to push it to github ?",initial:!0},{type:i=>i===!0?"password":null,name:"githubAccessToken",message:"What Github Personal Access Token can I use ?",validate:async i=>{let n=await E(i,o);return t.githubLogin=n,!!n},error:"Invalid Github Personal Access Token"},{type:i=>i?"text":null,name:"githubProjectName",message:"What will be the Github project name ?",initial:(i,n,a)=>n.workspaceName},{type:i=>i?"confirm":null,name:"githubPrivateRepo",message:"Do you want to make the repo private ?",initial:!0}],{onCancel:()=>{console.log("canceled by user"),process.exit(1)}}),r=Object.assign({},t,e,s);if(!r.workspaceName)throw new Error("The workspace name is required");if(!r.repositoriesFolder)throw new Error("The name of the repositories folder is required");await ee(r)}var te,je,Ae,qe,Ee,se=p(()=>{te=c(require("prompts"));f();oe();je="create",Ae="Create workspace",qe=function(e){},Ee=function(e){(async()=>{await Ue({verbose:!!e.verbose})})().catch(o=>{console.error(o),process.exit(1)})}});var ne,G,ie,ae=p(()=>{ne=c(require("fs")),G=c(require("path"));f();w();ie=async e=>{var s;let o=process.cwd(),t=d();for(let r of(s=t.repositories)!=null?s:[]){let i=G.default.resolve(o,t.repositoriesFolder),n=G.default.resolve(i,r.folder);ne.default.existsSync(n)||await S(i,r.repo),r.branch&&(await $(n,r.branch),await u(n,r.branch)),r.tag&&(await T(n,r.tag),await u(n,r.tag))}}});var ce={};y(ce,{builder:()=>Je,command:()=>Be,desc:()=>De,handler:()=>$e});async function Le(e){await ie(e)}var Be,De,Je,$e,pe=p(()=>{ae();Be="init",De="Init repositories from git",Je=function(e){},$e=function(e){(async()=>{await Le({verbose:!!e.verbose})})().catch(o=>{console.error(o),process.exit(1)})}});var le,ge,me,de=p(()=>{le=c(require("fs")),ge=c(require("path"));k();w();me=async e=>{let{repoFolder:o,verbose:t}=e,s=process.cwd(),{repositoriesFolder:r}=d();g(t)("Starting to remove a repo...");let n=ge.default.resolve(s,r,o);le.default.rmSync(n,{recursive:!0,force:!0}),H(o)}});var fe={};y(fe,{builder:()=>ze,command:()=>Me,desc:()=>_e,handler:()=>He});async function Ke(e){var i;let o=d(),t={hasChanges:!1},s=await(0,he.default)([{type:"select",name:"repoFolder",message:"Which folder do you want to remove ?",choices:((i=o.repositories)!=null?i:[]).map(n=>({title:n.folder,description:n.repo,value:n.folder})),validate:async n=>{try{let a=ue.default.resolve(process.cwd(),o.repositoriesFolder,n),x=await R(a);t.hasChanges=!x.isClean()}catch(a){console.error(a)}return!0}},{type:()=>t.hasChanges?"confirm":null,name:"confirmIgnoreChanges",message:"This repo has changes, do you want to ignore them ?",initial:!1}]),r=Object.assign({},t,e,s);if(!r.repoFolder)throw new Error("Invalid repo.");t.hasChanges&&!r.confirmIgnoreChanges||await me(r)}var ue,he,Me,_e,ze,He,we=p(()=>{ue=c(require("path")),he=c(require("prompts"));de();w();f();Me="remove-repo",_e="Remove a repository from workspace",ze=function(e){},He=function(e){(async()=>{await Ke({verbose:!!e.verbose})})().catch(o=>{console.error(o),process.exit(1)})}});var ye={};y(ye,{builder:()=>Xe,command:()=>Qe,desc:()=>Ve,handler:()=>Ye,updateCommand:()=>be});async function be(e){console.log(e)}var Qe,Ve,Xe,Ye,ve=p(()=>{Qe="update",Ve="Update repositories from git",Xe=function(e){},Ye=function(e){(async()=>{await be({verbose:!!e.verbose})})().catch(o=>{console.error(o),process.exit(1)})}});var Ze=q();require("yargs/yargs")(process.argv.slice(2)).usage("Usage: mws COMMAND").option("verbose",{alias:"v",type:"boolean",description:"false"}).command((Y(),v(X))).command((se(),v(re))).command((pe(),v(ce))).command((we(),v(fe))).command((ve(),v(ye))).version(Ze.version).demandCommand(1,"").recommendCommands().help().alias("h","help").argv;
//# sourceMappingURL=mws.map
